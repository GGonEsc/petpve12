function spatial = geg_petpve12_spatial
% wrapper for calling PET-PVEc spatial utilities
%
%_______________________________________________________________________
% Gabriel Gonzalez-Escamilla
% $Id: geg_petpvc12_tools.m 001 2015-03-08 16:20:04Z $

%rev = '$Rev: 036 $'; 04-May-2016

%_______________________________________________________________________

data         = cfg_files;
data.tag     = 'data';
data.name    = 'Volumes';
data.help    = {[...
'Select raw data (e.g. T1 images) for processing. ',...
'This assumes that there is one scan for each subject. ',...
'Note that multi-spectral (when there are two or more registered ',...
'images of different contrasts) processing is not yet implemented ',...
'for this method.']};
data.filter  = 'image';
data.ufilter = '.*';
data.num     = [1 Inf];

%========================================================================
%========================================================================
%------------------------------------------------------------------------
% Segmentation, Bias correction and Skull-stripping (spatial.segment)
%------------------------------------------------------------------------
%========================================================================
%========================================================================
tpm         = cfg_files;
tpm.tag     = 'tpm';
tpm.name    = 'Tissue Probability Map';
tpm.help    = {
               'Select the tissue probability image for this class. These should be maps of e.g. gray matter, white matter or cerebrospinal fluid probability. '
               'A nonlinear deformation field is estimated that best overlays the tissue probability maps on the individual subjects'' image. '
               'The current versions were crudely generated (by JA) using data that was kindly provided by Cynthia Jongen of the Imaging Sciences Institute at Utrecht, NL. '
               'Rather than assuming stationary prior probabilities based upon mixing proportions, additional information is used, based on other subjects'' brain images. '
               'Priors are usually generated by registering a large number of subjects together, assigning voxels to different tissue types and averaging tissue classes over subjects. '
               'The algorithm used here will employ these priors for the first initial segmentation and normalization. '
               'Six tissue classes are used: gray matter, white matter, cerebrospinal fluid, bone, non-brain soft tissue and air outside of the head and in nose, sinus and ears. '
               'These maps give the prior probability of any voxel in a registered image being of any of the tissue classes - irrespective of its intensity. '
               'The model is refined further by allowing the tissue probability maps to be deformed according to a set of estimated parameters. '
               'This allows spatial normalisation and segmentation to be combined into the same model.'
               ''
               'Selected tissue probability map must be in multi-volume nifti format and contain all six tissue priors.'
               }';
tpm.filter  = 'image';
tpm.ufilter = '.*';
tpm.def     = @(val)geg_petpve12_get_defaults('opts.tpm', val{:});
tpm.num     = [1 1];

%------------------------------------------------------------------------
% various options for estimating the segmentations
%------------------------------------------------------------------------
ngaus      = cfg_entry;
ngaus.tag  = 'ngaus';
ngaus.name = 'Gaussians per class';
ngaus.strtype = 'e';
ngaus.num  = [1 6];
ngaus.def  = @(val)geg_petpve12_get_defaults('opts.ngaus', val{:});
ngaus.help = {[...
'The number of Gaussians used to represent the intensity distribution '...
'for each tissue class can be greater than one. '...
'In other words, a tissue probability map may be shared by several clusters. '...
'The assumption of a single Gaussian distribution for each class does not '...
'hold for a number of reasons. '...
'In particular, a voxel may not be purely of one tissue type, and instead '...
'contain signal from a number of different tissues (partial volume effects). '...
'Some partial volume voxels could fall at the interface between different '...
'classes, or they may fall in the middle of structures such as the thalamus, '...
'which may be considered as being either gray or white matter. '...
'Various other image segmentation approaches use additional clusters to '...
'model such partial volume effects. '...
'These generally assume that a pure tissue class has a Gaussian intensity '...
'distribution, whereas intensity distributions for partial volume voxels '...
'are broader, falling between the intensities of the pure classes. '...
'Unlike these partial volume segmentation approaches, the model adopted '...
'here simply assumes that the intensity distribution of each class may '...
'not be Gaussian, and assigns belonging probabilities according to these '...
'non-Gaussian distributions. '...
'Typical numbers of Gaussians could be two for gray matter, two for white '...
'matter, two for CSF, three for bone, four for other soft tissues and ',...
'two for air (background).'],[...
'Note that if any of the Num. Gaussians is set to non-parametric, '...
'then a non-parametric approach will be used to model the tissue intensities. '...
'This may work for some images (e.g. CT), but not others - '...
'and it has not been optimized for multi-channel data. Note that it is likely to ',...
'be especially problematic for images with poorly behaved intensity histograms ',...
'due to aliasing effects that arise from having discrete values on the images.']};

%------------------------------------------------------------------------
biasreg      = cfg_menu;
biasreg.tag  = 'biasreg';
biasreg.name = 'Bias regularization';
biasreg.def  = @(val)geg_petpve12_get_defaults('opts.biasreg', val{:});
biasreg.labels = {...
'no regularization (0)','extremely light regularization (0.00001)',...
'very light regularization (0.0001)','light regularization (0.001)',...
'medium regularization (0.01)','heavy regularization (0.1)',...
'very heavy regularization (1)','extremely heavy regularization (10)'};
biasreg.values = {0, 0.00001, 0.0001, 0.001, 0.01, 0.1, 1.0, 10};
biasreg.help   = {[...
'MR images are usually corrupted by a smooth, spatially varying artifact that modulates the intensity ',...
'of the image (bias). ',...
'These artifacts, although not usually a problem for visual inspection, can impede automated ',...
'processing of the images. '],...
'',...
[...
'An important issue relates to the distinction between intensity variations that arise because of ',...
'bias artifact due to the physics of MR scanning, and those that arise due to different tissue ',...
'properties. The objective is to model the latter by different tissue classes, while modelling the ',...
'former with a bias field. ',...
'We know a priori that intensity variations due to MR physics tend to be spatially smooth, ',...
'whereas those due to different tissue types tend to contain more high frequency information. ',...
'A more accurate estimate of a bias field can be obtained by including prior knowledge about ',...
'the distribution of the fields likely to be encountered by the correction algorithm. ',...
'For example, if it is known that there is little or no intensity non-uniformity, then it would be wise ',...
'to penalize large values for the intensity non-uniformity parameters. ',...
'This regularization can be placed within a Bayesian context, whereby the penalty incurred is the negative ',...
'logarithm of a prior probability for any particular pattern of non-uniformity.'],...
['Knowing what works best should be a matter '...
'of empirical exploration.  For example, if your data has very little '...
'intensity non-uniformity artifact, then the bias regularization should '...
'be increased.  This effectively tells the algorithm that there is very little '...
'bias in your data, so it does not try to model it.']};

%------------------------------------------------------------------------
biasfwhm        = cfg_menu;
biasfwhm.tag    = 'biasfwhm';
biasfwhm.name   = 'Bias FWHM';
biasfwhm.labels = {...
'30mm cutoff','40mm cutoff','50mm cutoff','60mm cutoff','70mm cutoff',...
'80mm cutoff','90mm cutoff','100mm cutoff','110mm cutoff','120mm cutoff',...
'130mm cutoff','140mm cutoff','150mm cutoff','No correction'};
biasfwhm.values = {30,40,50,60,70,80,90,100,110,120,130,140,150,Inf};
biasfwhm.def    = @(val)geg_petpve12_get_defaults('opts.biasfwhm', val{:});
biasfwhm.help   = {[...
'FWHM of Gaussian smoothness of bias. ',...
'If your intensity non-uniformity is very smooth, then choose a large ',...
'FWHM. This will prevent the algorithm from trying to model out intensity variation ',...
'due to different tissue types. The model for intensity non-uniformity is one ',...
'of i.i.d. Gaussian noise that has been smoothed by some amount, ',...
'before taking the exponential. ',...
'Note also that smoother bias fields need fewer parameters to describe them. ',...
'This means that the algorithm is faster for smoother intensity non-uniformities.']};

%------------------------------------------------------------------------
warpreg      = cfg_entry;
warpreg.def  = @(val)geg_petpve12_get_defaults('opts.warpreg', val{:});
warpreg.tag  = 'warpreg';
warpreg.name = 'Warping Regularization';
warpreg.strtype = 'e';
warpreg.num     = [1 5];
warpreg.val     = {[0 0.001 0.5 0.05 0.2]};
warpreg.help    = {[...
'The objective function for registering the tissue probability maps to the ',...
'MR image to process, involves minimizing the sum of two terms. ',...
'One term gives a function of how probable the data is given the warping parameters. ',...
'The other is a function of how probable the parameters are, and provides a ',...
'penalty for unlikely deformations. ',...
'Smoother deformations are deemed to be more probable. ',...
'The amount of regularization determines the tradeoff between the terms. ',...
'Pick a value around one.  However, if your normalized images appear ',...
'distorted, then it may be an idea to increase the amount of ',...
'regularization (by an order of magnitude). ',...
'More regularization gives smoother deformations, ',...
'where the smoothness measure is determined by the bending energy of the deformations. ']};
%------------------------------------------------------------------------
affreg        = cfg_menu;
affreg.tag    = 'affreg';
affreg.name   = 'Affine Regularization';
affreg.labels = {'No Affine Registration','ICBM space template - European brains',...
    'ICBM space template - East Asian brains','Average sized template','No regularization'};
affreg.values = {'','mni','eastern','subj','none'};
affreg.def    = @(val)geg_petpve12_get_defaults('opts.affreg', val{:});
affreg.help   = {[...
'The procedure is a local optimization, so it needs reasonable initial '...
'starting estimates. Images should be placed in approximate alignment '...
'using the Display function of SPM before beginning. '...
'A Mutual Information affine registration with the tissue '...
'probability maps (D''Agostino et al, 2004) is used to achieve '...
'approximate alignment. '...
'Note that this step does not include any model for intensity non-uniformity. '...
'This means that if the procedure is to be initialized with the affine '...
'registration, then the data should not be too corrupted with this artifact. '...
'If there is a lot of intensity non-uniformity, then manually position your '...
'image in order to achieve closer starting estimates, and turn off the '...
'affine registration.'],...
'',...
[...
'Affine registration into a standard space can be made more robust by ',...
'regularization (penalizing excessive stretching or shrinking).  The ',...
'best solutions can be obtained by knowing the approximate amount of ',...
'stretching that is needed (e.g. ICBM templates are slightly bigger ',...
'than typical brains, so greater zooms are likely to be needed). ',...
'For example, if registering to an image in ICBM/MNI space, then choose this ',...
'option. If registering to a template that is close in size, then ',...
'select the appropriate option for this.']};

%------------------------------------------------------------------------
samp      = cfg_entry;
samp.tag  = 'samp';
samp.name = 'Sampling distance';
samp.strtype = 'e';
samp.num  = [1 1];
samp.def  = @(val)geg_petpve12_get_defaults('opts.samp', val{:});
samp.help = {'This encodes the approximate distance between sampled points when estimating the model parameters. ',...
    'Smaller values use more of the data, but the procedure is slower and needs more memory. Determining the ''''best'''' setting involves a compromise between speed and accuracy. '};

%------------------------------------------------------------------------
opts      = cfg_branch;
opts.tag  = 'opts';
opts.name = 'Estimation options';
opts.val  = {tpm,ngaus,biasreg,biasfwhm,affreg,warpreg,samp};
opts.help = {['Various options can be adjusted in order to improve the performance of the ',...
'algorithm with your data.  Knowing what works best should be a matter ',...
'of empirical exploration. For example, if your data has very little ',...
'intensity nonuniformity artifact, then the bias regularization should ',...
'be increased. This effectively tells the algorithm that there is very little ',...
'bias in your data, so it does not try to model it. ']};

%_______________________________________________________________________
% output options 
%-----------------------------------------------------------------------
vox      = cfg_entry;
vox.tag  = 'vox';
vox.name = 'Voxel size for normalized images';
vox.strtype = 'e';
vox.num  = [1 1];
vox.def  = @(val)geg_petpve12_get_defaults('extopts.vox', val{:});
vox.help = {['The (isotropic) voxel sizes of any spatially normalized written images. ',...
 'A non-finite value will be replaced by the average voxel size of ',...
 'the tissue probability maps used by the segmentation. ']};

%------------------------------------------------------------------------
cleanup      = cfg_menu;
cleanup.tag  = 'cleanup';
cleanup.name = 'Clean up any partitions';
cleanup.help = {['',...
'This uses a crude routine for extracting the brain from segmented ',...
'images. It begins by taking the white matter, and eroding it a ',...
'couple of times to get rid of any odd voxels. The algorithm ',...
'continues on to do conditional dilations for several iterations, ',...
'where the condition is based upon gray or white matter being present. ',...
'This identified region is then used to clean up the gray and white ',...
'matter partitions, and has a slight influences on the CSF partition. '],'',[...
'If you find pieces of brain being chopped out in your data, then you ',...
'may wish to disable or tone down the cleanup procedure. ']};
cleanup.labels = {'No Cleanup','Light Cleanup','Thorough Cleanup'};
cleanup.values = {0 1 2};
cleanup.def    = @(val)geg_petpve12_get_defaults('extopts.cleanup', val{:});

%------------------------------------------------------------------------
sanlm      = cfg_menu;
sanlm.tag  = 'sanlm';
sanlm.name = 'Use SANLM de-noising filter';
sanlm.help = {['',...
'This function applies an spatial adaptive non local means denoising filter ',...
'to the data. This filter will remove noise while ',...
'preserving edges. The smoothing filter size is automatically estimated based on ',...
'the local variance in the image. ']};
sanlm.labels = {'No denoising','Denoising','Denoising (multi-threaded)'};
sanlm.values = {0 1 2};
sanlm.def    = @(val)geg_petpve12_get_defaults('extopts.sanlm', val{:});

%------------------------------------------------------------------------
mrf      = cfg_entry;
mrf.tag  = 'mrf';
mrf.name = 'MRF weighting';
mrf.strtype = 'e';
mrf.num  = [1 1];
mrf.help = {['',...
'A Hidden Markov Random Field (HMRF) is used to encode spatial information ',...
'through spatial constraints of neighboring voxels (Zhang et al. IEEE TMI 2001). ',...
'Neighboring voxels are expected to have the same class labels. The prior probability ',...
'of the class and the likelihood probability of the observation is combined to ',...
'estimate the Maximum a posteriori (MAP). It is not necessary to change the MRF ',...
'weighting, because the ORNLM filter will have a much larger de-noising effect. ',...
'A value of "0" will deselect the MRF. ']};
mrf.def  = @(val)geg_petpve12_get_defaults('extopts.mrf', val{:});

%------------------------------------------------------------------------
finalmask      = cfg_menu;
finalmask.tag  = 'finalmask';
finalmask.name = 'Apply final mask after segmenting';
finalmask.help = {['', ...
'This option uses morphological operations to apply a final masking.']};
finalmask.labels = {'Dont apply final masking','Apply final masking'};
finalmask.values = {0 1};
finalmask.def    = @(val)geg_petpve12_get_defaults('extopts.finalmask', val{:});

%------------------------------------------------------------------------
gcut = cfg_menu;
gcut.tag  = 'gcut';
gcut.name = 'Use graph-cuts for Skull-Stripping';
gcut.help = {['', ...
'This option enables skull-stripping with graph-cuts approach. ']};
gcut.labels = {'Dont use graph-cuts for skull-stripping','Use graph-cuts for skull-stripping'};
gcut.values = {0 1};
gcut.def    = @(val)geg_petpve12_get_defaults('extopts.gcut', val{:});

%------------------------------------------------------------------------
darteltpm        = cfg_files;
darteltpm.tag    = 'darteltpm';
darteltpm.name   = 'DARTEL Template';
darteltpm.help   = {'Selected tissue probability map must be in multi-volume nifti format and contain all six tissue priors. '}';
darteltpm.filter = 'image';
darteltpm.ufilter = '_1_';
darteltpm.def    = @(val)geg_petpve12_get_defaults('extopts.darteltpm', val{:});
darteltpm.num    = [1 1];

savenrm      = cfg_menu;
savenrm.tag  = 'svwarped';
savenrm.name = 'Save warped images?';
savenrm.labels = {'modulated warped (affine+non-linear)','modulated warped non-linear only', 'warped','no'};
savenrm.values = {3 2 1 0};
savenrm.val    = {0};
savenrm.help   = {['Produces tissue class images in alignment with the template, ',...
'but multiplies (“modulates”) the voxel values by: A) the Jacobian determinant , ',...
'(i.e., linear and non-linear components) derived from the spatial normalization; ',...
'B) the non-linear components only. '],[' ',...
'A, is useful for VBM analyses and allows comparing the absolute amount of tissue ',...
'(e.g., “volume” of gray matter; Good et al. 2001; Neuroimage). ',...
'B, is useful for VBM analyses and allows comparing the absolute amount of tissue ',...
'corrected for individual brain sizes. ',...
'This option is similar to using “Affine+non-linear” (see above) in combination with ',...
'“global normalization” when building the statistics. However, it is recommended to ',...
'use the option “non-linear only” as it applies the correction directly to the data, ',...
'rather than to the statistical model. '],[' ',...
'Default option is “Modulated normalized – non-linear only” ',...
'will result in an analysis of relative differences in regional GM volume, ',...
'corrected for individual brain size. ']};

savenjc      = cfg_menu;
savenjc.tag  = 'svjacobian';
savenjc.name = 'Save jacobian maps?';
savenjc.labels = {'yes','no'};
savenjc.values = {1 0};
savenjc.val    = {0};
savenjc.help   = {'The Jacobian determinant for each voxel can be written in normalized space (jac_wrp1*). '};

saveexp      = cfg_menu;
saveexp.tag  = 'svexports';
saveexp.name = 'Save DARTEL exports?';
saveexp.labels = {'yes','no'};
saveexp.values = {1 0};
saveexp.val    = {1};
saveexp.help   = {'Write DARTEL export files (rp*). '};

normhigh         = cfg_branch;
normhigh.tag     = 'normhigh';
normhigh.name    = 'High-dimensional: DARTEL';
normhigh.val     = {darteltpm,savenrm,savenjc,saveexp};
normhigh.help    = {'high-dimensional DARTEL normalization. DARTEL normalized images are indicated by an additional ''''wr'''' (e.g. wrp*). '}';

dartelwarp      = cfg_choice;
dartelwarp.tag  = 'dartelwarp';
dartelwarp.name = 'DARTEL normalization';
dartelwarp.val  = {normhigh};
dartelwarp.values = {normhigh};
dartelwarp.help   = {'DARTEL spatial normalization. '};

%------------------------------------------------------------------------
extopts      = cfg_branch;
extopts.tag  = 'extopts';
extopts.name = 'Extended options';
extopts.val  = {dartelwarp,sanlm,mrf,gcut,finalmask,cleanup};
extopts.help = {'Extended options'};

%------------------------------------------------------------------------
% options for data
%------------------------------------------------------------------------
native        = cfg_menu;
native.tag    = 'native';
native.name   = 'Native space';
native.labels = {'none','yes'};
native.values = {0 1};
native.help   = {['The native space option allows you to produce a tissue class image (c*) that is in alignment with the original/* (see Figure \ref{seg1})*/. ',...
    'It can also be used for ''''importing'''' into a form that can be used with the DARTEL toolbox (rp*).']};
native.def  = @(val)geg_petpve12_get_defaults('output.bias.native', val{:});

bias        = cfg_branch;
bias.tag    = 'bias';
bias.name   = 'Bias Corrected';
bias.val    = {native};
bias.help   = {['',...
'This is the option to save a bias corrected version of your image. ',...
'MR images are usually corrupted by a smooth, spatially varying artifact that modulates the intensity ',...
'of the image (bias). ',...
'These artifacts, although not usually a problem for visual inspection, can impede automated ',...
'processing of the images. The bias corrected version should have more uniform intensities within ',...
'the different types of tissues and can be saved in native space. ']};

%------------------------------------------------------------------------
native.def  = @(val)geg_petpve12_get_defaults('output.label.native', val{:});
label       = cfg_branch;
label.tag   = 'label';
label.name  = 'Tissue-label image';
label.val   = {native};
label.help  = {['This is the option to save a labeled version of your tissue segments. ',...
'The Tissue-labeled images  are single files containing binary non-overlapping tissue segments, ',...
'obtained via majority rule, based on the probability of a specific tissue types at each voxel ',...
'and taking into account partial volume effects of mixing different tissue classes (GM-WM and GM-CSF)',...
'within a single image voxel. '],['',...
'This image can be used in the PET PVE correction modules.',...
' ']};

%------------------------------------------------------------------------
native.def = @(val)geg_petpve12_get_defaults('output.GM.native', val{:});
gray       = cfg_branch;
gray.tag   = 'GM';
gray.name  = 'gray matter';
gray.val   = {native};
gray.help  = {'Options to produce gray matter images: p1*.nii. '};%, wp1*.img and mwp1*.img

native.def = @(val)geg_petpve12_get_defaults('output.WM.native', val{:});
white      = cfg_branch;
white.tag  = 'WM';
white.name = 'White matter';
white.val  = {native};
white.help = {'Options to produce white matter images: p2*.nii. '};%, wp2*.img and mwp2*.img

native.def = @(val)geg_petpve12_get_defaults('output.CSF.native', val{:});
csf        = cfg_branch;
csf.tag    = 'CSF';
csf.name   = 'Cerebrospinal fluid (CSF)';
csf.val    = {native};
csf.help   = {'Options to produce CSF images: p3*.nii. '};%, wp3*.img and mwp3*.img

nativeSS        = cfg_menu;
nativeSS.tag    = 'nativeSS';
nativeSS.name   = 'Image to Skull-Strip';
nativeSS.labels = {'Orig T1','Bias-corrected'};
nativeSS.values = {[1 0],[0 1]};
nativeSS.help   = {'This allows to produce a T1 or bias-corrected skull-stripped image. '};

BMoutput      = cfg_menu;
BMoutput.tag  = 'BMoutput';
BMoutput.name = 'Save binary Brain Mask';
BMoutput.help = {['', ...
'This option enables saving the brain mask after the skull-stripping approach.']};
BMoutput.labels = {'yes','no'};
BMoutput.values = {1 0};
BMoutput.def    = @(val)geg_petpve12_get_defaults('output.BM.native', val{:});

nativeSS.def = @(val)geg_petpve12_get_defaults('output.SS.native', val{:});
SS           = cfg_branch;
SS.tag       = 'SS';
SS.name      = 'Skull-Striped (SS)';
SS.val       = {nativeSS,BMoutput};
SS.help      = {'Options to produce skull-stripped images: ss*.nii.'};

%------------------------------------------------------------------------
warps        = cfg_menu;
warps.tag    = 'warps';
warps.name   = 'Deformation Fields';
warps.labels = {...
    'none',...
    'Image->Template (forward)',...
    'Template->Image (inverse)',...
    'inverse + forward'};
warps.values = {[0 0],[1 0],[0 1],[1 1]};
warps.def    = @(val)geg_petpve12_get_defaults('output.warps', val{:});
warps.help   = {['Deformation fields are used by the Deformations Utility of SPM. ',...
    'For spatially normalizing images to MNI space, you will need the forward deformation. ',...
    'It is also possible to transform data in MNI space on to the individual subject (native space), which requires the inverse transform. ',...
    'Deformations are saved as .nii files, which contain three volumes to encode the x, y and z coordinates. ',...
    'Be aware that this deformation fields are not from DARTEL procedure, but SPM-like normalization. ']};

%------------------------------------------------------------------------
output      = cfg_branch;
output.tag  = 'output';
output.name = 'Writing options';
output.val  = {gray, white, csf, bias, SS, label, warps};
output.help = {['', ...
'This routine produces spatial normalisation parameters (*_seg8.mat files) by default. ', ...
' And also always saves the bias corrected and local histogram equalized, skull-stripped image (m1*.nii).' ...
'The *_seg8.mat files can be used into the DARTEL toolbox to import your data'],...
'',...
[...
'In addition, it also produces files that can be used for doing inverse normalization. ',...
'If you have an image of regions defined in the standard space, then the inverse deformations ',...
'can be used to warp these regions so that it approximately overlay your image. ',...
'To use this facility, the bounding-box and voxel sizes should be set to non-finite values ',...
'(e.g. [NaN NaN NaN] for the voxel sizes, and ones(2,3)*NaN for the bounding box. ',...
'This would be done by the spatial normalization module, which allows you to select a ',...
'set of parameters that describe the nonlinear warps, and the images that they should be applied to.'],...
'',...
[...
'There are a number of options about what data you would like the routine to produce. ',...
'The routine can be used for producing images of tissue classes, as well as bias corrected images, and ', ...
' skull-stripped images. ',...
'The native space option will produce a tissue class image (c*) that is in alignment with ',...
'the original/* (see Figure \ref{seg1})*/. In the petpve12 toolbox, the voxel size ',...
'of the output images is the native mm as default. The HMRF (hidden Markov Random Fields), ',...
' weighting is estimated automatically in dependence of the noise in the data. ',...
'The produced images of the tissue classes can be imported to DARTEL toolbox for doing voxel-based morphometry (both un-modulated and modulated). '],...
'',...
[... 
'\begin{figure} ',...
'\begin{center} ',...
'\includegraphics[width=150mm]{images/seg1} ',...
'\end{center} ',...
'\caption{Segmentation results. ',...
'These are the results that can be obtained in the original space of the image ',...
'(i.e. the results that are not spatially normalized). ',...
'Top left: original image (X.nii). ',...
'Top right: bias corrected image (mX.nii). ',...
'Middle and bottom rows: segmented gray matter (c1X.nii), ',...
'white matter (c2X.nii) and CSF (c3X.nii). \label{seg1}} ',...
'\end{figure} */'],...
['/*',...
'\begin{figure} ',...
'\begin{center} ',...
'\includegraphics[width=150mm]{images/seg2} ',...
'\end{center} ',...
'\caption{Segmentation results. ',...
'These are the spatially normalized results that can be obtained ',...
'(note that CSF data is not shown). ',...
'Top row: The tissue probability maps used to guide the segmentation. ',...
'\end{figure} */'],...
[...
'A deformation field is a vector field, where three values are associated with ',...
'each location in the field. The field maps from co-ordinates in the ',...
'normalized image back to co-ordinates in the original image. The value of ',...
'the field at co-ordinate [x y z] in the normalized space will be the ',...
'co-ordinate [x'' y'' z''] in the original volume. ',...
'The gradient of the deformation field at a co-ordinate is its Jacobian ',...
'matrix, and it consists of a 3x3 matrix:'],...
'',...
'%   /                      \',...
'%   | dx''/dx  dx''/dy dx''/dz |',...
'%   |                       |',...
'%   | dy''/dx  dy''/dy dy''/dz |',...
'%   |                       |',...
'%   | dz''/dx  dz''/dy dz''/dz |',...
'%   \                      /',...
['/* \begin{eqnarray*}',...
'\begin{pmatrix}',...
'\frac{dx''}{dx} & \frac{dx''}{dy} & \frac{dx''}{dz}\cr',...
'\frac{dy''}{dx} & \frac{dy''}{dy} & \frac{dy''}{dz}\cr',...
'\frac{dz''}{dx} & \frac{dz''}{dy} & \frac{dz''}{dz}\cr',...
'\end{pmatrix}\end{eqnarray*}*/'],...
[...
'The value of dx''/dy is a measure of how much x'' changes if y is changed by a ',...
'tiny amount. ']};

%------------------------------------------------------------------------
segment      = cfg_exbranch;
segment.tag  = 'segment';
segment.name = 'PETPVE12: Segment MRI';
segment.val  = {data,output,opts,extopts};
segment.prog = @geg_segment;
segment.vout = @vout;
segment.help = {[...
'This segmentation approach is the one from the VBM8 toolbox. ',...
'The algorithm is described in the VBM8 manual and in Gaser (2009)',...
'Differences to the method described in the Unified Segmentation paper: ',... 
'(i) a slightly different treatment of the mixing proportions, ',...
'(ii) the use of an improved registration model, ',...
'(iii) the ability to use multi-spectral data and ',...
'(iv) an extended set of tissue probability maps. '],...
'',[...
'This function can be used for bias correcting, skull-stripping ',...
'or segmenting your data.'],...
'',...
[...
'Many investigators use tools within for Partial Volume Corrections(PVC) on MRI images. '...
'PVC performs voxel-wise (See Tohka et al., 2004, 2013). '...
'Skull-Stripping requires the MRI images to be segmented into '...
'different tissue classes, and previously bias corrected, to perform '...
'the graph-cuts algorithm. '],...
'',...
[...
'This model also includes parameters that account '...
'for image intensity non-uniformity. '...
'Estimating the model parameters (for a maximum a posteriori solution) '...
'that involves alternating among classification and bias correction. '...
'This approach was thought to provide better results than simple serial applications of each component.'],...
'',...
['As per defaults, the outcomes will be the bias corrected normalized volumes ',...
'(wm*) and the tissue segments (i.e., the modulated normalized (non-linear only) gray matter ',...
'(m0wrp1*) and white matter (m0wrp2) segments of each volume). ']};

%========================================================================
%========================================================================
%------------------------------------------------------------------------
% Skull-Stripping using pre-computed GM/WM segments
%------------------------------------------------------------------------
%========================================================================
%========================================================================
data2strip         = cfg_files;
data2strip.tag     = 'data';
data2strip.name    = 'MRI Volumes';
data2strip.help    = {[...
'Select raw data (e.g. T1 images) for Skull-Stripping. ',...
'This assumes that there is one scan for each subject. ']};
data2strip.filter  = 'image';
data2strip.ufilter = '.*';
data2strip.num     = [1 Inf];

GM_data         = cfg_files;
GM_data.tag     = 'tiss1';
GM_data.name    = 'GM segments';
GM_data.help    = {'Select gray matter tissue segment maps (p1* or c1*) for Skull-Stripping. ',...
['This assumes that there is one image for each subject, ', ...
'and that they are ordered as the MRI volumes. ']};
GM_data.filter  = 'image';
GM_data.ufilter = {'^c1.*\.nii','^p1.*\.nii'};
GM_data.num     = [1 Inf];

WM_data         = cfg_files;
WM_data.tag     = 'tiss2';
WM_data.name    = 'WM segments';
WM_data.help    = {'Select white matter tissue segment maps (p2* or c2*) for Skull-Stripping. ',...
['This assumes that there is one image for each subject. ', ...
'and that they are ordered as the MRI volumes. ']};
WM_data.filter  = 'image';
WM_data.ufilter = {'^c2.*\.nii','^p2.*\.nii'};
WM_data.num     = [1 Inf];

SSoutput        = cfg_menu;
SSoutput.tag    = 'SSoutput';
SSoutput.name   = 'Save binary Brain Mask';
SSoutput.help   = {['', ...
'This option enables saving the binary brain mask used for the skull-stripping approach.']};
SSoutput.labels = {'yes','no'};
SSoutput.values = {1 0};
SSoutput.def    = @(val)geg_petpve12_get_defaults('output.BM.native', val{:});

SStype      = cfg_menu;
SStype.tag  = 'SStype';
SStype.name = 'Skull-Stripping method';
SStype.help = {['', ...
'This option sets the selection of the skull-stripping approach.']};
SStype.labels = {'Use morphological operations for Skull-Stripping','Use thresholding operations for Skull-Stripping'};
SStype.values = {1 0};
SStype.def    = @(val)geg_petpve12_get_defaults('SSopts.morph', val{:});

SSCln      = cfg_menu;
SSCln.tag  = 'SScleanup';
SSCln.name = 'Clean up any partitions';
SSCln.help = {[...
'This uses a crude routine for extracting the brain from segmented ',...
'images. It begins by taking the white matter, and eroding it a ',...
'couple of times to get rid of any odd voxels. The algorithm ',...
'continues on to do conditional dilations for several iterations, ',...
'where the condition is based upon gray or white matter being present. ',...
'This identified region is then used to clean up the gray and white ',...
'matter partitions.'],'',[...
'If you find pieces of brain being chopped out in your data, then you ',...
'may wish to disable or tone down the cleanup procedure. ']};
SSCln.labels = {'No Cleanup','Light Cleanup','Thorough Cleanup'};
SSCln.values = {0 1 2};
SSCln.def    = @(val)geg_petpve12_get_defaults('extopts.cleanup', val{:});

SStypeO      = cfg_menu;
SStypeO.tag  = 'SStypeO';
SStypeO.name = 'Apply final masking';
SStypeO.help = {['', ...
    'This option is recommended if your final images have empty ventricles, ',...
    'or any holes. ',...
    'It is not the default option so you should check for holes in your images. '],...
    '',['', ...
    'This option allows the application of a more dilated masking for skull-stripping when morphological operations are selected.']};
SStypeO.labels = {'Apply final masking','Do not apply final masking'};
SStypeO.values = {1 0};
SStypeO.def    = @(val)geg_petpve12_get_defaults('SSopts.finalmask', val{:});

SStypeOpt      = cfg_branch;
SStypeOpt.tag  = 'SStypeOpt';
SStypeOpt.name = 'Morphological options';
SStypeOpt.val  = {SStypeO};
SStypeOpt.help = {['In case that morphological operations are selected, ', ...
    'this options will be applied to the approach.']};

SSopts         = cfg_entry;
SSopts.tag     = 'SS_Thresh';
SSopts.name    = 'Threshold for GM/WM';
SSopts.strtype = 'e';
SSopts.num     = [1 1];
SSopts.help    = {[ '', ...
'If morphological operations are selected this value will be ignored. '] ...
'', ...
['If no thresholding is chosen. To create the brain mask, ',...
'GM and WM segments will be thresholded with this number.',...
'Then the tissue classes are combined to create an initial mask, ',...
'that later will be processed to fill the ventricles. ',...
'A value of "0" will avoid any thesholding on the images.']};
SSopts.def    = @(val)geg_petpve12_get_defaults('SSopts.thresh', val{:});

%------------------------------------------------------------------------
SkullStrip      = cfg_exbranch;
SkullStrip.tag  = 'SkullStrip';
SkullStrip.name = 'PETPVE12: Skull-Strip with GM/WM';
SkullStrip.val  = {data2strip,GM_data,WM_data,SStype,SSCln,SSoutput,SStypeOpt,SSopts};
SkullStrip.prog = @geg_SSusingSegments;
SkullStrip.help = {[...
    'This will attempt to create a brain mask from ', ...
    'the selected GM and WM tissue segments. ' ],...
    '', [''...
    'Two options are possible here: '], ...
    '', [''...
    'A) Using information from the seg8.mat files; or ' ]...
    '', [''...
    'B) Threshold the tissue segments.'] ...
    '', [...
    'Either option is selected, tissue segments are processed ' ...
    'with some morphological operations to create a full brain mask, without outer CSF. ']};


%========================================================================
%========================================================================
%------------------------------------------------------------------------
% Partial volume Effects correction (MG method)
%------------------------------------------------------------------------
%========================================================================
%========================================================================
PET_data         = cfg_files;
PET_data.tag     = 'PETdata';
PET_data.name    = 'Coregistered PET data';
PET_data.filter  = 'image';
PET_data.ufilter = '.*';
PET_data.num     = [1 Inf];
PET_data.help    = {'Select raw MRI-corregistered PET data for processing. ',...
'This assumes that there is one image per subject. '};

GM_data.help = {'Select gray matter tissue segment maps (c1* or p1*). ',...
'This assumes that there is one map for each subject. '};

WM_data.help = {'Select white matter tissue segment maps (c2* or p2*). ',...
'This assumes that there is one map for each subject. '};

PVElbl_data         = cfg_files;
PVElbl_data.tag     = 'pvelbl';
PVElbl_data.name    = 'Tissue-label image';
PVElbl_data.filter  = 'image';
PVElbl_data.ufilter = '.*';
PVElbl_data.num     = [1 Inf];
PVElbl_data.help    = {'Select tissue-label image. ',...
'This assumes that there is one image for each subject. '};

Tsegs      = cfg_branch;
Tsegs.tag  = 'Tsegs';
Tsegs.name = 'Probabilistic maps';
Tsegs.val  = {GM_data,WM_data};
Tsegs.help = {'Select the segmented probabilistic tissue (GM and WM) maps. ',...
    'Can be the tissue probability maps obtained with different algorithms, i.e. output from SPM 2/99/5/8/12, VBM8 or PETPVE12. '};

lblsegs      = cfg_branch;
lblsegs.tag  = 'lblsegs';
lblsegs.name = 'Tissue-labeled image';
lblsegs.val  = {PVElbl_data};
lblsegs.help = {'It uses the single tissue-labeled image generated by VBM8 (p0*.nii) or PETPVE12 (c0*.nii). '};

SegImgs        = cfg_choice;
SegImgs.tag    = 'SegImgs';
SegImgs.name   = 'Tissue segments';
SegImgs.values = {Tsegs,lblsegs};
SegImgs.help   = {'This option allows for the specification of the input tissue maps used for the WM/CSF spill-over.'};
SegImgs.val    = {Tsegs};
%------------------------------------------------------------------------
% point-spread function (PSF) FWHM (mm): default is isotropic FWHM.
PSF         = cfg_entry;
PSF.tag     = 'fwhm_PSF';
PSF.name    = 'PET PSF (FWHM in mm)';
PSF.strtype = 'e';
PSF.num     = [1 3];
PSF.help    = {['Point Spread Function (PSF) of the PET scanner. ',...
' '],[...
'The user needs to specify reasonable FWHM values for his reconstructed images. ',...
' '],[...
'This is used to convolve the tissue segments. ',...
' '],[...
'Commonly, PVEc methods implementation assume a homogeneous (isotropic), ',...
'Gaussian-shaped point-spread function (PSF) of the scanner, ',...
'which is specified by its full-width at half maximum (FWHM) in all directions. ',...
'Altough, the user can specify a non-isotropic PSF. Widths around 6 - 8 mm^3 are the most common. ',...
' '],[...
'Default is isotropic. ',...
' ']};
PSF.def     = @(val)geg_petpve12_get_defaults('PVEopts.PSF', val{:});

gmthresh         = cfg_entry;
gmthresh.tag     = 'gmthresh';
gmthresh.name    = 'Gray matter threshold';
gmthresh.strtype = 'e';
gmthresh.num     = [1 1];
gmthresh.help    = {'Threshold to create binary GM tissue segment. Only voxels above threshold are preserved. ',...
'Optimal threshold may depend on the quality and acquisition parameters of the structural MRI scan as well as on the particular segmentation algorithm used to define different tissue types. ',...
'Default setting is 0.5. ',...
'This threshold resulted in reasonably sized GM segments when segmenting our test MRI data (from ADNI) with the VBM8 segmentation routine as implemented in the PETPVE12 toolbox - segmentation module. '};
gmthresh.def     = @(val)geg_petpve12_get_defaults('PVEopts.GMthr', val{:});
%------------------------------------------------------------------------
CSF_data         = cfg_files;
CSF_data.tag     = 'tiss3';
CSF_data.name    = 'From CSF segments';
CSF_data.filter  = 'image';
CSF_data.ufilter = {'^c3.*\.nii','^p3.*\.nii'};
CSF_data.num     = [1 Inf];
CSF_data.help    = {'Select cerebrospinal fluid segment maps (c3* or p3*). ',...
'This assumes that there is one map for each subject. '};

CSFincl         = cfg_menu;
CSFincl.tag     = 'CSFother';
CSFincl.name    = 'From tissue-labeled image';
CSFincl.labels  = {'Use CSF map in tissue-labeled image'};
CSFincl.values  = {1};
CSFincl.val     = {1};
CSFincl.help    = {'Use cerebrospinal fluid segment from tissue-labeled image or as input vector. '};

CSFcalc         = cfg_choice;
CSFcalc.tag     = 'CSFcalc';
CSFcalc.name    = 'Estimate CSF signal';
CSFcalc.values  = {CSF_data,CSFincl};
CSFcalc.val     = {CSF_data};
CSFcalc.help    = {'It uses the tissue segmented (CSF) maps (probabilistic or labeled). ',...
    'Can be the tissue probability maps obtained with different algorithms, i.e. output from SPM 2/99/5/8/12, VBM8 or PETPVE12. '};

CSFzeroing         = cfg_menu;
CSFzeroing.tag     = 'CSFzeroing';
CSFzeroing.name    = 'Zero CSF signal';
CSFzeroing.labels  = {'Consider zero signal form CSF'};
CSFzeroing.values  = {1};
CSFzeroing.val     = {1};
CSFzeroing.help    = {'This assumes that the CSF signal for each subject is zero. '};

CSFsignal         = cfg_choice;
CSFsignal.tag     = 'CSFsignal';
CSFsignal.name    = 'CSF signal options';
CSFsignal.values  = {CSFcalc,CSFzeroing};
CSFsignal.val     = {CSFcalc};
CSFsignal.def     = @(val)geg_petpve12_get_defaults('PVEopts.CSFzeroing', val{:});
CSFsignal.help    = {['For most commonly used radiotracers the CSF signal can be assumed to be zero, ',...
    'and spill-in effects are typically neglected in the PVE correction procedure. '],...
    'By setting this parameter to true, the PVE correction will also estimate and correct CSF spill-in effects. '};
%------------------------------------------------------------------------
TissConv        = cfg_menu;
TissConv.tag    = 'TissConv';
TissConv.name   = 'Save convolved tissue maps';
TissConv.help   = {['', ...
'The PSF-convolved tissue segments can be written to disk. ' ,...
'Default is not to save them. ']};
TissConv.labels = {'yes','no'};
TissConv.values = {1 0};
TissConv.def    = @(val)geg_petpve12_get_defaults('PVEopts.TissConv', val{:});

PVEopts      = cfg_branch;
PVEopts.tag  = 'PVEopts';
PVEopts.name = 'PVE-correction options';
PVEopts.val  = {PSF,gmthresh,CSFsignal,TissConv};
PVEopts.help = {['Options for the PVE. ', ...
    'This are the options to perform the MG-PVEc. ']};

% Some options for the WM/CSF signals
% ---------------------------------------------------------------------
WMvals         = cfg_entry;
WMvals.tag     = 'WMv';
WMvals.name    = 'WM vector';
WMvals.help    = {'Vector of WM signal.'};
WMvals.strtype = 'r';
WMvals.num     = [Inf 1];

CSFvals         = cfg_entry;
CSFvals.tag     = 'CSFv';
CSFvals.name    = 'CSF vector';
CSFvals.help    = {'Vector of CSF signal.'};
CSFvals.strtype = 'r';
CSFvals.num     = [Inf 1];

type1      = cfg_branch;
type1.tag  = 'type1';
type1.name = 'User specified values';
type1.val  = {WMvals,CSFvals};
type1.help = {['Enter WM and CSF pre-computed constant "activity" values as single vectors. A vector of zeros can be entered for CSF "activity"',...
    ' '],[' ',...
    'Same order as PET images is expected. ']};
% ---------------------------------------------------------------------
defs        = cfg_files;
defs.tag    = 'defs';
defs.name   = 'Inverse Deformation Field';
defs.filter = '.*iy_.*\.nii$';
defs.num    = [1 inf];
defs.help   = {['Deformations can be thought of as vector fields, and represented ',...
'by three-volume images.  In SPM, deformation fields are saved in ',...
'NIfTI format, with dimensions xdim x ydim x zdim x 1 x 3. ',...
'Each voxel contains the x, y and z mm coordinates of where the deformation points.']};

ffield         = files('Flow field','flowfield','nifti',[1 inf]);
ffield.ufilter = '^u_.*';
ffield.help    = {['The flow field stores the deformation information. '...
     'The same field can be used for both forward or backward deformations '...
     '(or even, in principle, half way or exaggerated deformations).']};

K      = mnu('Time Steps','K',...
        {'1','2','4','8','16','32','64','128','256','512'},...
        {0,1,2,3,4,5,6,7,8,9});
K.val  = {6};
K.help = {['The number of time points used for solving the '...
     'partial differential equations.  A single time point would be '...
     'equivalent to a small deformation model. '...
     'Smaller values allow faster computations, '...
     'but are less accurate in terms '...
     'of inverse consistency and may result in the one-to-one mapping '...
     'breaking down.']};
 
drtl      = branch('DARTEL flow field','dartel',{ffield,K});
drtl.help = {'DARTEL flow field(s). After deformation, an identity matrix is applied to improve alignment. '};

InDefs        = cfg_choice;
InDefs.tag    = 'InDefs';
InDefs.name   = 'Deformation input';
InDefs.values = {drtl,defs};
InDefs.help   = {'File that describes the mapping from the template to the individual’s anatomy. '};
InDefs.val    = {drtl};

WMmask         = cfg_files;
WMmask.tag     = 'WMmasks';
WMmask.name    = 'Deep WM Binary Mask';
WMmask.help    = {'Select the WM mask in standard space. It will be deformed to match subject’s native space (Dimensions and voxel size) using the DARTEL flow_field/deformation_matrix.'};
WMmask.filter  = {'image'};
WMmask.ufilter = '.*';
WMmask.num     = [1 1];

type2      = cfg_branch;
type2.tag  = 'type2';
type2.name = 'From standard-space deep-WM mask';
type2.val  = {WMmask, InDefs};
type2.help = {['Specify deformation matrices to transform the deep WM mask (i.e. centrum semiovale) from standard space to subject''s space. ',...
    'Then compute the constant "activity" in that WM mask. ']};
% ---------------------------------------------------------------------
thrVal         = cfg_entry;
thrVal.tag     = 'wmcsfthresh';
thrVal.name    = 'WM threshold';
thrVal.strtype = 'e';
thrVal.num     = [1 1];
thrVal.help    = {'Threshold for WM/CSF tissue segments. '};
thrVal.def     = @(val)geg_petpve12_get_defaults('PVEopts.WMCSFthr', val{:});

type3      = cfg_branch;
type3.tag  = 'type3';
type3.name = 'From WM tissue segments';
type3.val  = {thrVal};
type3.help = {'If probabilistic maps are selected as tissue segments, ',...
    'PET signal will be averaged across all voxels that surpass the specified threshold value (default is 0.5). '};
% ---------------------------------------------------------------------
thrEro         = cfg_entry;
thrEro.tag     = 'erothresh';
thrEro.name    = 'WM erosion threshold';
thrEro.strtype = 'e';
thrEro.num     = [1 1];
thrEro.help    = {'Threshold to erode the WM tissue segment. A value between 0.1 and 0.05 is spected '};
thrEro.def     = @(val)geg_petpve12_get_defaults('PVEopts.EroThresh', val{:});

type4      = cfg_branch;
type4.tag  = 'type4';
type4.name = 'Eroding WM/CSF tissue segments';
type4.val  = {thrEro};
type4.help = {'It uses a Gaussian weighting function to erode (remove the voxels at the edge) the tissue maps, and then compute signal in surplus tissue.'};
% ---------------------------------------------------------------------
GTMtxt         = cfg_files;
GTMtxt.tag     = 'GTMtxt';
GTMtxt.name    = 'GTM output txt file';
GTMtxt.filter  = 'pvc*.*';
GTMtxt.ufilter = '^*\.txt';
GTMtxt.num     = [1 Inf];
GTMtxt.help    = {'Select the pve*.txt files as output from the GTM method. '};

type5      = cfg_branch;
type5.tag  = 'type5';
type5.name = 'Using values from GTM (mMG)';
type5.val  = {GTMtxt};
type5.help = {'This is the option to create the mMG images by using the corrected WM signal from the ROI-based GTM. '};
% ---------------------------------------------------------------------
PVE_Const_opts        = cfg_choice;
PVE_Const_opts.tag    = 'PVE_Const_opts';% constant variable (WM/CSF) options for PVE correction
PVE_Const_opts.name   = 'Estimation of WM (and CSF) signal';
PVE_Const_opts.values = {type1, type2, type3, type4, type5};
PVE_Const_opts.help   = {'Specify the method used to compute the WM/CSF "activity", assumed to be a constant value. Pre-estimated values can be entered.'};
PVE_Const_opts.val    = {type3};
% ---------------------------------------------------------------------
PVEcorrection      = cfg_exbranch;
PVEcorrection.tag  = 'PVEcorrection';
PVEcorrection.name = 'PETPVE12: PET-PVE correction (MG)';
PVEcorrection.val  = {PET_data,SegImgs,PVEopts,PVE_Const_opts};
PVEcorrection.prog = @geg_PVEcorrection;
PVEcorrection.help = {[...
    'A three compartment algorithm known as the Muller-Gartner (MG) PVE correction is implemented. ', ...
    'It considers WM and CSF tissue "activity" as a constant value (at some occasions CSF is assumed to be zero). ']};

%========================================================================
%========================================================================
%------------------------------------------------------------------------
% Partial volume Effects correction (GTM-Rousset ROIs method)
%------------------------------------------------------------------------
%========================================================================
%========================================================================
% Already defined: 
% PET_data 
% GM_data
% WM_data
% CSF_data
% PSF - point spread function
% gmthresh - threshold for GM (used for MG implementation)
% CSFzeroing - consider a zero CSF constant activity
% TissConv - save/delete convolved tissue segments
% PVEopts - {PSF,gmthresh,CSFzeroing,TissConv} Same options as MG-PVE
% ---------------------------------------------------------------------
CSFsig         = cfg_menu;
CSFsig.tag     = 'CSFincl';
CSFsig.name    = 'Single CSF ROI';
CSFsig.labels  = {'Single CSF ROI from tissue map'};
CSFsig.values  = {1};
CSFsig.val     = {1};
CSFsig.help    = {'Use the CSF tissue as a ROI. '};

CSFzero         = cfg_menu;
CSFzero.tag     = 'CSFzeroing';
CSFzero.name    = 'Atlas-defined CSF ROIs';
CSFzero.labels  = {'Pre-defined CSF ROIs in Atlas '};
CSFzero.values  = {1};
CSFzero.val     = {1};
CSFzero.help    = {'This assumes that the CSF ROIs are already defined in the atlas. '};

CSFsigIn         = cfg_choice;
CSFsigIn.tag     = 'CSFsigIn';
CSFsigIn.name    = 'CSF signal';
CSFsigIn.values  = {CSFzero,CSFsig};
CSFsigIn.val     = {CSFzero};
CSFsigIn.help    = {' '};

CSFcalc.name     = 'GTM inclusion of CSF';
 
CSFsignal        = cfg_branch;
CSFsignal.tag    = 'CSFsignal';
CSFsignal.name   = 'CSF signal options';
CSFsignal.val    = {CSFsigIn,CSFcalc};
CSFsignal.help   = {[
'For most commonly used radiotracers the CSF signal is assumed to be zero, ',...
'and spill-over effects are typically neglected during the PVE correction procedure in most PET studies. ',...
' ',...
'However, the GTM method is aimed at controlling for these effects in small regions where the CSF spill-over can be appreciable. ' ,...
'Accordingly, the toolbox will always include the CSF into the GTM algorithm. ',...
' '],['',...
'The inclusion of CSF in the analysis can be performed in two different ways:',...
' '],['',...
'Predefined CSF ROIs in the input atlas (Default). Note, that when using this toolbox to create the WM ROIs from GM-atlas the CSF ROIs are created. ',...
' '],['',...
'A single CSF ROI, created with from the tissue map. Helpful when your standard GM/WM-atlas does not include any CSF ROI. ']};
% ---------------------------------------------------------------------
% {['This used for masking of automatically parcellated gray matter labels. ',...
%     ' '],[
%     'When automatically estimating individual gray matter labels based on propagation of a ',...
%     'standard anatomical atlas it is advisable to mask the resulting labels with the segmented ',...
%     'gray matter compartment. This procedure aims to reduce misalignments due to inaccuracies of ',...
%     'the automated registration/propagation procedure. ',...
%     ' ']};
% ---------------------------------------------------------------------
PVEopts      = cfg_branch;
PVEopts.tag  = 'PVEopts';
PVEopts.name = 'PVE-correction options';
PVEopts.val  = {PSF,CSFsignal};
PVEopts.help = {['Options for the PVE. ', ...
    'This are the options to perform the GTM. ']};
% ---------------------------------------------------------------------
wmThr         = cfg_menu;
wmThr.tag     = 'wmthresh';
wmThr.name    = 'Tissue threshold';
wmThr.labels = {'Thresholded tissues'};
wmThr.values  = {1};
wmThr.val     = {1};
wmThr.help    = {'Threshold to binarize WM/CSF tissue segments before atlas multiplication. ',...
    'Default is to use the same as for GM (0.5). ',...
    '',...
    'This can be changed via the geg_petpve12_defaults.m '};

wmEro         = cfg_menu;
wmEro.tag     = 'wmero';
wmEro.name    = 'Tissue erosion';
wmEro.labels  = {'Erode tissues'};
wmEro.values  = {1};
wmEro.val     = {1};
wmEro.help    = {'Erode the mask to remove edge voxels. '};

wmOpts         = cfg_choice;
wmOpts.tag     = 'wmOpts';
wmOpts.name    = 'WM/CSF options for GTM inclusion';
wmOpts.values  = {wmThr,wmEro};
wmOpts.help    = {[...
'Options to include WM and CSF ROIs into the GTM: ',...
'Threshold WM/CSF tissue segments (Default). ',...
'Erode WM/CSF tissue segments. ']};
wmOpts.val  = {wmThr};
% ---------------------------------------------------------------------
ParcAtlas         = cfg_files;
ParcAtlas.tag     = 'ParcAtlas';
ParcAtlas.name    = 'Individual ROI atlas';
ParcAtlas.help    = {'Select the atlas images for every subject. They all must have the same dimensions, orientation and voxel sizes as their corresponding subject.'};
ParcAtlas.filter  = {'image'};
ParcAtlas.ufilter = '.*';
ParcAtlas.num     = [1 Inf];

type1      = cfg_branch;
type1.tag  = 'type1';
type1.name = 'Atlas in subject''s native space';
type1.val  = {ParcAtlas};
type1.help = {'It uses a volumetric ROIs from a chosen atlas in subject''s native space, i.e. after manual delimitation). '};
% ---------------------------------------------------------------------
ParcAtlas.num     = [1 1];
ParcAtlas.name    = 'Template atlas';
ParcAtlas.def     = @(val)geg_petpve12_get_defaults('PVEopts.RoiAtlas', val{:});
ParcAtlas.help    = {['Select the *.nii volume image containing all gray matter parcels labeled with unique numbers. ',...
    ' '],[...
    'It will be deformed to match native subject''s anatomy. ',...
    ' '],[...
    'Default choice is the Desikan-killiany structural atlas in the “Atlases” folder of the toolbox. ',...
    ' ']};

InDefs.help = {['File that describes the mapping from the template to the individual’s anatomy. ',...
    ' '],[...
    'Two options are allowed for input: “DARTEL flow field” (u_*.nii) or “Inverse deformation field” (iy_*.nii).',...
    ' '],[...
    'A deformed version of the atlas volume image to the subject’s native space is written to disk (prefixed by w*)',...
    ' ']};

type2      = cfg_branch;
type2.tag  = 'type2';
type2.name = 'Template atlas in standard space';
type2.val  = {ParcAtlas, InDefs};
type2.help = {'Specify deformation matrices to transform the selected atlas from standard space to subject''s space. '};
% ---------------------------------------------------------------------
PVE_AParc_opts        = cfg_choice;
PVE_AParc_opts.tag    = 'PVE_AParc_opts';
PVE_AParc_opts.name   = 'GTM creation options';
PVE_AParc_opts.values = {type1, type2};
PVE_AParc_opts.help   = {'This option allows the specification of the atlas used to create the Geometric Transfer Matrix (GTM). '};
PVE_AParc_opts.val    = {type2};
% ---------------------------------------------------------------------
ParcDescF         = cfg_files;
ParcDescF.tag     = 'ParcDescF';
ParcDescF.name    = 'Atlas descriptor file';
ParcDescF.filter  = '.*';
ParcDescF.ufilter = '.txt';
ParcDescF.num     = [1 1];
ParcDescF.def     = @(val)geg_petpve12_get_defaults('PVEopts.RoiAtlasDesc', val{:});
ParcDescF.help    = {['' ...
'Select the *.txt file that describes the Atlas. ',...
'Two columns tab separated: ROI names (1st column) and numerical ID''s (2nd column) of every ROIs on the chosen atlas. ']};
% ---------------------------------------------------------------------
PVEcorrection2      = cfg_exbranch;
PVEcorrection2.tag  = 'PVEcorrection2';
PVEcorrection2.name = 'PETPVE12: PET-PVE correctionR (GTM)';
PVEcorrection2.val  = {PET_data,SegImgs,PVEopts,wmOpts,PVE_AParc_opts,ParcDescF};
PVEcorrection2.prog = @geg_PVEcorrection2;
PVEcorrection2.help = {['',...
    'For the analysis of human brain uptake the implementation allows the use of the Geometric Transfer Matrix (GTM) correction with any atlas or ROIs set in subject space . ',...
    'The standard Atlas is automatically adjusted to the patient''s anatomy by means of DARTEL flowfields or the inversed deformation matrix. ', ...
    'This is often call as the modified Muller-Garter (mMG) PVEcorrection (Rousset et al., 1998). ',...
    'The ROIs of structures supposed to concentrate the tracer (normally GM ROIs) are dilated using the PSF, ',...
    'whereas the low-activity ROIs (WM and CSF ROIs) are eroded. ']};

%========================================================================
%========================================================================
%------------------------------------------------------------------------
% Create DARTEL imported images and apply deformations to other data
%------------------------------------------------------------------------
%========================================================================
%========================================================================
resF         = cfg_files;
resF.tag     = 'resF';
resF.name    = 'Seg8 files';
resF.filter  = '.*';
resF.ufilter = '.mat';
resF.num     = [1 Inf];
resF.help    = {['' ...
'Select all *_seg8.mat files, which were produced by SPM12/VBM8/PETPVE12 toolbox. ']};

DrtlExport      = cfg_exbranch;
DrtlExport.tag  = 'DrtlExport';
DrtlExport.name = 'PETPVE12: create DARTEL exported';
DrtlExport.val  = {resF};
DrtlExport.prog = @geg_createDRTLimport;
DrtlExport.help = {[...
    ' writes all the rc*.nii files necessary to perform DARTEL alignment. ', ...
    ' ']};

%========================================================================
%========================================================================
%------------------------------------------------------------------------
% Create WM ROIs on individual atlas
%------------------------------------------------------------------------
%========================================================================
%========================================================================
% Already defined: 
% GM_data
% WM_data
% CSF_data
% SegImgs
% PVEopts - {PSF,gmthresh,CSFzeroing,TissConv} Same options as MG-PVE
% wmOpts
% PVE_AParc_opts
% ParcDescF
% ---------------------------------------------------------------------
CSF_data.name = 'CSF segments';

Tsegs2      = cfg_branch;
Tsegs2.tag  = 'Tsegs';
Tsegs2.name = 'Probabilistic maps';
Tsegs2.val  = {GM_data,WM_data,CSF_data}; 
Tsegs2.help = {'The segmented probabilistic tissue maps (GM, WM and CSF). ',...
    'These can be the tissue probability maps obtained with different algorithms, i.e. output from SPM 2/99/5/8/12, VBM8 or PETPVE12'};

SegImgs.values = {Tsegs2,lblsegs};
SegImgs.help   = {'This option allows for the specification of the tissue maps.'};
SegImgs.val    = {Tsegs2};
% ---------------------------------------------------------------------
wmThr.help  = {'Uses a threshold to binarize the WM/CSF tissue segments to limit the WM/CSF atlas regions. Default is 0.5. ',...
    ' ',...
    'This can be changed via the geg_petpve12_defaults.m '};

wmOpts.values  = {wmThr,wmEro};
wmOpts.name    = 'Options to avoid tissue overlapping';
wmOpts.val     = {wmThr};
wmOpts.help    = {[''...
'Options to avoid overlapping between GM/WM and CSF tissues before ROI creation: '],...
[''...
'Threshold WM/CSF tissue segments (Default). '],...
[''...
'Erode WM/CSF tissue segments. ']};
% ---------------------------------------------------------------------
oneCSF         = cfg_menu;
oneCSF.tag     = 'oneCSF';
oneCSF.name    = 'Single CSF-tissue ROI';
oneCSF.labels  = {'Single CSF ROI'};
oneCSF.values  = {1};
oneCSF.val     = {1};
oneCSF.help    = {'Add a unique CSF ROI (Default). '};

CSFrois         = cfg_menu;
CSFrois.tag     = 'CSFrois';
CSFrois.name    = 'Add multiple atlas-CSF ROIs';
CSFrois.labels  = {'Atlas defined CSF ROIs'};
CSFrois.values  = {1};
CSFrois.val     = {1};
CSFrois.help    = {'Add as many ROIs as it can. '};

csfOpts         = cfg_choice;
csfOpts.tag     = 'csfOpts';
csfOpts.name    = 'CSF options for Atlas inclusion';
csfOpts.values  = {oneCSF,CSFrois};
csfOpts.help    = {'Options to include CSF into the Atlas: ',...
'One single CSF ROI (Default). ',...
'Multiple CSF ROIs. '};
csfOpts.val     = {oneCSF};
% ---------------------------------------------------------------------
ParcAtlas.def  = @(val)geg_petpve12_get_defaults('WMrois.RoiAtlas', val{:});

type2.val  = {ParcAtlas, InDefs};
type2.help = {'Specify deformation matrices to transform the selected atlas from standard space to subject''s space. '};

PVE_AParc_opts.name   = 'Template Atlas options';
PVE_AParc_opts.values = {type2};
PVE_AParc_opts.val    = {type2};
PVE_AParc_opts.help   = {'This option allows the specification of the GM atlas used to create the WM ROIs. ',...
    'Note that the Atlas ROIs should be thick enough to contain WM. ',...
    '**Also, if the atlas includes some CSF labels, then, the ''multiple CSF ROIs'' option for CSF inclusion may worth it. '};
% ---------------------------------------------------------------------
ParcDescF.def     = @(val)geg_petpve12_get_defaults('WMrois.RoiAtlasDesc', val{:});
ParcDescF.help    = {'' ...
'Select a *.txt file that describes GM the Atlas. ',...
'Two columns tab separated: ROI names (1st column) and numerical ID''s (2nd column) of every ROIs on the chosen atlas. ',...
''};
% ---------------------------------------------------------------------
WMrois      = cfg_exbranch;
WMrois.tag  = 'WMrois';
WMrois.name = 'PETPVE12: Create WM-ROIs on Atlas';
WMrois.val  = {SegImgs,wmOpts,csfOpts,PVE_AParc_opts,ParcDescF};
WMrois.prog = @geg_create_atlas_WMrois;
WMrois.help = {['',...
    'For the analysis of human brain uptake the implementation allows the use of the Geometric Transfer Matrix (GTM) correction with any atlas or ROIs set in subject space . ',...
    'The standard Atlas is automatically adjusted to the patient''s anatomy by means of DARTEL flowfields or the inversed deformation matrix. ', ...
    'This is often call as the modified Muller-Garter (mMG) PVEcorrection (Rousset et al., 1998). ',...
    'The ROIs of structures supposed to concentrate the tracer (normally GM ROIs) are dilated using the PSF, ',...
    'whereas the low-activity ROIs (WM and CSF ROIs) are eroded. ']};

%========================================================================
%========================================================================
%------------------------------------------------------------------------
% The toolbox spatial definitions (petpve.spatial.)
%------------------------------------------------------------------------
%========================================================================
%========================================================================
spatial        = cfg_choice;
spatial.name   = 'Spatial';
spatial.tag    = 'spatial';
spatial.values = {segment,SkullStrip,DrtlExport,WMrois,PVEcorrection,PVEcorrection2};
return

%========================================================================
%========================================================================
% Sub-Functions
%________________________________________________________________________
%________________________________________________________________________
%------------------------------------------------------------------------
%------------------------------------------------------------------------
%________________________________________________________________________
%________________________________________________________________________
function dep = vout(job)
% set dependenies between jobs
% This depends on job contents, which may not be present when virtual
% outputs are calculated.
opts  = job.output;
tissue(1).warped = [0  0  0];
tissue(1).native = [opts.GM.native  0  0];
tissue(2).warped = [0  0  0];
tissue(2).native = [opts.WM.native  0  0];
tissue(3).warped = [0  0  0];
tissue(3).native = [opts.CSF.native 0  0];
cdep = cfg_dep;
cdep(end).sname      = 'Seg Params';
cdep(end).src_output = substruct('.','param','()',{':'});
cdep(end).tgt_spec   = cfg_findspec({{'filter','mat','strtype','e'}});
if opts.bias.native,
    cdep(end+1)          = cfg_dep;
    cdep(end).sname      = 'Bias Corr Images';
    cdep(end).src_output = substruct('()',{1}, '.','biascorr','()',{':'});
    cdep(end).tgt_spec   = cfg_findspec({{'filter','image','strtype','e'}});
end;
if opts.label.native,
    cdep(end+1)          = cfg_dep;
    cdep(end).sname      = 'Label Images';
    cdep(end).src_output = substruct('()',{1}, '.','label','()',{':'});
    cdep(end).tgt_spec   = cfg_findspec({{'filter','image','strtype','e'}});
end;
if opts.warps(1),
    cdep(end+1)          = cfg_dep;
    cdep(end).sname      = 'Deformation Field';
    cdep(end).src_output = substruct('()',{1}, '.','fordef','()',{':'});
    cdep(end).tgt_spec   = cfg_findspec({{'filter','image','strtype','e'}});
end;
if opts.warps(2),
    cdep(end+1)          = cfg_dep;
    cdep(end).sname      = 'Inverse Deformation Field';
    cdep(end).src_output = substruct('()',{1}, '.','invdef','()',{':'});
    cdep(end).tgt_spec   = cfg_findspec({{'filter','image','strtype','e'}});
end;
for i=1:numel(tissue),
    if tissue(i).native(1),
        cdep(end+1)          = cfg_dep;
        cdep(end).sname      = sprintf('c%d Images',i);
        cdep(end).src_output = substruct('.','tiss','()',{i},'.','c','()',{':'});
        cdep(end).tgt_spec   = cfg_findspec({{'filter','image','strtype','e'}});
    end    
end
if opts.SS.nativeSS(1),
    cdep(end+1)          = cfg_dep;
    cdep(end).sname      = 'Skull-Stripped T1 Images';
    cdep(end).src_output = substruct('()',{1}, '.','T1ss','()',{':'});
    cdep(end).tgt_spec   = cfg_findspec({{'filter','image','strtype','e'}});
end
if opts.SS.nativeSS(2),
    cdep(end+1)          = cfg_dep;
    cdep(end).sname      = 'Skull-Stripped Bias-corrected Images';
    cdep(end).src_output = substruct('()',{1}, '.','BIASss','()',{':'});
    cdep(end).tgt_spec   = cfg_findspec({{'filter','image','strtype','e'}});
end
dep = cdep;
%________________________________________________________________________
function files_item = files(name, tag, fltr, num)
files_item        = cfg_files;
files_item.name   = name;
files_item.tag    = tag;
files_item.filter = fltr;
files_item.num    = num;
function menu_item = mnu(name, tag, labels, values)
menu_item        = cfg_menu;
menu_item.name   = name;
menu_item.tag    = tag;
menu_item.labels = labels;
menu_item.values = values;
function branch_item = branch(name, tag, val)
branch_item      = cfg_branch;
branch_item.name = name;
branch_item.tag  = tag;
branch_item.val  = val;